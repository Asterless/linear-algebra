package "Luna-Flow/linear-algebra/mutable"

import(
  "Luna-Flow/luna-generic"
)

// Values
fn[T : Add] add_constant(Matrix[T], T) -> Matrix[T]

fn[T : @luna-generic.Conjugate] adjoint(Matrix[T]) -> Matrix[T]

fn[T] col_to_array(Matrix[T], Int) -> Array[T]

fn[T] horizontal_combine(Matrix[T], Matrix[T]) -> Matrix[T]

fn[T : @luna-generic.One + @luna-generic.Zero] identity(Int) -> Matrix[T]

fn[T : @luna-generic.One + Mul + Add + Neg] lerp(Vector[T], Vector[T], T) -> Vector[T]

fn[T : Add + Mul] lin_comb(T, Vector[T], T, Vector[T]) -> Vector[T]

fn[T] matrix_to_transpose(Matrix[T]) -> Transpose[T]

fn[T : Compare + @luna-generic.Zero] null(Matrix[T]) -> Bool

fn[T] op_get(Lens[T], Int) -> T

fn[T : @luna-generic.Semiring] pow(Matrix[T], Int) -> Matrix[T]

fn[T : Compare + @luna-generic.Num + Sub + @luna-generic.Inverse] reduce_row_elimination(Matrix[T]) -> Matrix[T]

fn[T] row_to_array(Matrix[T], Int) -> Array[T]

fn[T : Mul] scale(Matrix[T], T) -> Matrix[T]

fn[T : Mul + @luna-generic.Zero] scaled_matrix(Vector[T]) -> Matrix[T]

fn[T] swap_cols(Matrix[T], Int, Int) -> Unit

fn[T] swap_rows(Matrix[T], Int, Int) -> Unit

fn[T : Mul] tensor_product(Vector[T], Vector[T]) -> Matrix[T]

fn[T] to_array(Matrix[T]) -> Array[T]

fn[T] to_col_matrix(Vector[T]) -> Matrix[T]

fn[T] to_row_matrix(Vector[T]) -> Matrix[T]

fn[T] transpose(Matrix[T]) -> Matrix[T]

fn[T] vertical_combine(Matrix[T], Matrix[T]) -> Matrix[T]

// Types and methods
type LenTranspose[T]
fn[T] LenTranspose::op_get(Self[T], Int) -> T
fn[T] LenTranspose::op_set(Self[T], Int, T) -> Unit

type Lens[T]
fn[T] Lens::op_get(Self[T], Int) -> T
fn[T] Lens::op_set(Self[T], Int, T) -> Unit

type Matrix[T]
fn[T : Add] Matrix::add_constant(Self[T], T) -> Self[T]
fn[T : @luna-generic.Conjugate] Matrix::adjoint(Self[T]) -> Self[T]
fn[T] Matrix::col_to_array(Self[T], Int) -> Array[T]
fn[T] Matrix::copy(Self[T]) -> Self[T]
fn[T] Matrix::from_2d_array(Array[Array[T]]) -> Self[T]
fn[T] Matrix::from_array(Int, Int, Array[T]) -> Self[T]
fn[T] Matrix::horizontal_combine(Self[T], Self[T]) -> Self[T]
fn[A] Matrix::make(Int, Int, (Int, Int) -> A) -> Self[A]
fn[T, U] Matrix::map(Self[T], (T) -> U) -> Self[U]
fn[T] Matrix::map_col(Self[T], Int, (T) -> T) -> Unit
fn[T] Matrix::map_row(Self[T], Int, (T) -> T) -> Unit
fn[T] Matrix::matrix_to_transpose(Self[T]) -> Transpose[T]
fn[T] Matrix::new(Int, Int, T) -> Self[T]
fn[T : Compare + @luna-generic.Zero] Matrix::null(Self[T]) -> Bool
fn[T] Matrix::op_get(Self[T], Int) -> Lens[T]
fn[T : @luna-generic.Semiring] Matrix::pow(Self[T], Int) -> Self[T]
fn[T : Compare + @luna-generic.Num + Sub + @luna-generic.Inverse] Matrix::reduce_row_elimination(Self[T]) -> Self[T]
fn[T] Matrix::row_to_array(Self[T], Int) -> Array[T]
fn[T : Mul] Matrix::scale(Self[T], T) -> Self[T]
fn[T] Matrix::swap_cols(Self[T], Int, Int) -> Unit
fn[T] Matrix::swap_rows(Self[T], Int, Int) -> Unit
fn[T] Matrix::to_array(Self[T]) -> Array[T]
fn[T] Matrix::transpose(Self[T]) -> Self[T]
fn[T] Matrix::vertical_combine(Self[T], Self[T]) -> Self[T]
impl[T : Add] Add for Matrix[T]
impl[T : Eq] Eq for Matrix[T]
impl[T : Mul + Add] Mul for Matrix[T]
impl[T : Neg] Neg for Matrix[T]
impl[T : Show] Show for Matrix[T]
impl[T : Add + Neg] Sub for Matrix[T]

type Transpose[T]
fn[T : Add] Transpose::add_constant(Self[T], T) -> Self[T]
fn[T : @luna-generic.Conjugate] Transpose::adjoint(Self[T]) -> Self[T]
fn[T] Transpose::copy(Self[T]) -> Self[T]
fn[T] Transpose::horizontal_combine(Self[T], Self[T]) -> Self[T]
fn[T, U] Transpose::map(Self[T], (T) -> U) -> Self[U]
fn[T] Transpose::map_col(Self[T], Int, (T) -> T) -> Unit
fn[T] Transpose::map_row(Self[T], Int, (T) -> T) -> Unit
fn[T : Compare + @luna-generic.Zero] Transpose::null(Self[T]) -> Bool
fn[T] Transpose::op_get(Self[T], Int) -> LenTranspose[T]
fn[T : @luna-generic.Semiring] Transpose::pow(Self[T], Int) -> Self[T]
fn[T : Compare + @luna-generic.Num + Sub + @luna-generic.Inverse] Transpose::reduce_row_elimination(Self[T]) -> Self[T]
fn[T : Mul] Transpose::scale(Self[T], T) -> Self[T]
fn[T] Transpose::swap_cols(Self[T], Int, Int) -> Unit
fn[T] Transpose::swap_rows(Self[T], Int, Int) -> Unit
fn[T] Transpose::transpose_to_matrix(Self[T]) -> Matrix[T]
fn[T] Transpose::vertical_combine(Self[T], Self[T]) -> Self[T]
impl[T : Add] Add for Transpose[T]
impl[T : Eq] Eq for Transpose[T]
impl[T : Mul + Add] Mul for Transpose[T]
impl[T : Neg] Neg for Transpose[T]
impl[T : Show] Show for Transpose[T]
impl[T : Add + Neg] Sub for Transpose[T]

type Vector[A]
fn[T : Add] Vector::add_constant(Self[T], T) -> Self[T]
fn[A] Vector::copy(Self[A]) -> Self[A]
fn[T] Vector::from_array(Array[T]) -> Self[T]
fn[A : Mul] Vector::left_scale(Self[A], A) -> Self[A]
fn[A : Mul] Vector::left_scale_inplace(Self[A], A) -> Unit
fn[A] Vector::length(Self[A]) -> Int
fn[T : @luna-generic.One + Mul + Add + Neg] Vector::lerp(Self[T], Self[T], T) -> Self[T]
fn[A] Vector::make(Int, A) -> Self[A]
fn[A] Vector::makei(Int, (Int) -> A) -> Self[A]
fn[A, B] Vector::map(Self[A], (A) -> B) -> Self[B]
fn[A] Vector::map_inplace(Self[A], (A) -> A) -> Unit
fn[A] Vector::op_get(Self[A], Int) -> A
fn[A] Vector::op_set(Self[A], Int, A) -> Unit
fn[A : Mul] Vector::right_scale(A, Self[A]) -> Self[A]
fn[A : Mul] Vector::right_scale_inplace(A, Self[A]) -> Unit
fn[T : Mul + @luna-generic.Zero] Vector::scaled_matrix(Self[T]) -> Matrix[T]
fn[T : Mul] Vector::tensor_product(Self[T], Self[T]) -> Matrix[T]
fn[T] Vector::to_col_matrix(Self[T]) -> Matrix[T]
fn[T] Vector::to_row_matrix(Self[T]) -> Matrix[T]
fn[A, U, V] Vector::zip_with(Self[A], Self[U], (A, U) -> V) -> Self[V]
impl[T : Add] Add for Vector[T]
impl[T : Mul] Mul for Vector[T]
impl[T : Neg] Neg for Vector[T]
impl[T : Show] Show for Vector[T]

// Type aliases

// Traits

