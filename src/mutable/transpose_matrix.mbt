///|
/// Matrix stored in column-major (transpose) format for efficient column
/// operations.
///
/// This data structure represents a matrix where elements are stored column by
/// column in a single array, which is the transpose of the typical row-major
/// storage format. This layout provides better performance for operations that
/// primarily work with columns, such as matrix multiplication and column
/// transformations.
///
/// The matrix has dimensions `row` × `col`, and element at position (i, j) is
/// stored at index `j * row + i` in the data array.
///
/// Fields:
///
/// * `row` : Number of rows in the matrix.
/// * `col` : Number of columns in the matrix.
/// * `data` : Underlying array storing matrix elements in column-major order.
struct Transpose[T] {
  row : Int
  col : Int
  data : Array[T]
} derive(Eq)

///|
/// Row accessor for transpose matrix elements providing indexed get/set
/// operations.
///
/// Fields:
///
/// * `set` : Function to set an element at a given column index.
/// * `get` : Function to get an element at a given column index.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([[1, 2, 3], [4, 5, 6]]).matrix_to_transpose()
/// let row = m[0]  // Get first row accessor
/// inspect(row[1], content="4")  // Get element at column 1
/// row[1] = 10  // Set element at column 1
/// inspect(row[1], content="10")
/// ```
///
struct LenTranspose[T] {
  set : (Int, T) -> Unit
  get : (Int) -> T
}

///|
/// Converts a transpose matrix to its string representation in a human-readable
/// format.
///
/// The string representation displays each row of the transpose matrix on a
/// separate line, with elements separated by commas and each row enclosed in
/// vertical bars (|). This provides a clear visual representation of the matrix
/// structure.
///
/// Parameters:
///
/// * `s` : The transpose matrix to convert to string.
///
/// Returns a string representation of the transpose matrix with rows separated
/// by newlines and elements formatted within vertical bars.
///
/// Example:
///
/// ```moonbit
/// let m = @mutable.Matrix::from_2d_array([[1, 2, 3], [4, 5, 6]]).matrix_to_transpose()
/// inspect(m.to_string(), content="|1, 4|\n|2, 5|\n|3, 6|")
/// ```
///
pub impl[T : Show] Show for Transpose[T] with to_string(s) {
  let mut res = ""
  for i in 0..<s.row {
    res = res + "|"
    for j in 0..<s.col {
      res = res + s.data[j * s.row + i].to_string()
      if j < s.col - 1 {
        res = res + ", "
      }
    }
    res = res + "|"
    if i < s.row - 1 {
      res = res + "\n"
    }
  }
  res
}

///|
/// Implements output formatting for `Transpose[T]` types by writing their
/// string representation to a logger.
///
/// Parameters:
///
/// * `s` : The transpose matrix to format for output.
/// * `l` : The logger to write the formatted output to.
///
pub impl[T : Show] Show for Transpose[T] with output(s, l) {
  l.write_string(s.to_string())
}

///|
/// Creates a new transpose matrix by applying a function to generate elements
/// at each position.
///
/// Parameters:
///
/// * `row` : The number of rows in the transpose matrix.
/// * `col` : The number of columns in the transpose matrix.
/// * `f` : A function that takes row and column indices and returns the element
///   at that position.
///
/// Returns a new `Transpose[A]` matrix with the specified dimensions and
/// elements generated by the function.
///
/// Example:
///
/// ```moonbit
/// let m = Transpose::make(3, 2, (i, j) => { i * 2 + j })
/// // Creates a 3x2 transpose matrix where element at (i,j) equals i*2+j
/// ```
///
pub fn[A] Transpose::make(
  row : Int,
  col : Int,
  f : (Int, Int) -> A,
) -> Transpose[A] {
  { row, col, data: Array::makei(row * col, fn(i) { f(i / row, i % row) }) }
}

///|
/// Applies a transformation function to each element of the transpose matrix,
/// returning a new transpose matrix with the transformed elements.
///
/// Parameters:
///
/// * `self` : The transpose matrix to transform.
/// * `f` : The transformation function to apply to each element.
///
/// Returns a new transpose matrix of type `Transpose[U]` where each element is
/// the result of applying `f` to the corresponding element in the original
/// matrix.
///
/// Example:
///
/// ```moonbit
/// let m = @mutable.Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let doubled = m.map(fn(x) { x * 2 })
/// // doubled contains a transpose matrix with elements [2, 6, 4, 8]
/// ```
///
pub fn[T, U] Transpose::map(self : Transpose[T], f : (T) -> U) -> Transpose[U] {
  { row: self.row, col: self.col, data: self.data.map(f) }
}

///|
/// Applies a function to each element in the specified column of the transpose
/// matrix, modifying the matrix in place.
///
/// Parameters:
///
/// * `self` : The transpose matrix to be modified.
/// * `col` : The index of the column to apply the function to.
/// * `f` : The function to apply to each element in the column.
///
/// Example:
///
/// ```moonbit
/// let m = @mutable.Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// m.map_col(0, fn(x) { x * 2 })
/// // The first column elements are now doubled
/// ```
///
pub fn[T] Transpose::map_col(
  self : Transpose[T],
  col : Int,
  f : (T) -> T,
) -> Unit {
  for i in 0..<self.row {
    self.data[i + self.row * col] = f(self.data[i + self.row * col])
  }
}

///|
/// Applies a transformation function to all elements in a specific row of the
/// transpose matrix in-place.
///
/// Parameters:
///
/// * `self` : The transpose matrix to modify.
/// * `row` : The index of the row to transform (0-based).
/// * `f` : The transformation function to apply to each element in the row.
///
/// Example:
///
/// ```moonbit
/// let m = @mutable.Matrix::from_2d_array([[1, 2, 3], [4, 5, 6]]).matrix_to_transpose()
/// m.map_row(0, fn(x) { x * 2 })
/// // Row 0 is now [2, 8] (elements doubled)
/// ```
///
pub fn[T] Transpose::map_row(
  self : Transpose[T],
  row : Int,
  f : (T) -> T,
) -> Unit {
  for i in 0..<self.col {
    self.data[row + self.row * i] = f(self.data[row + self.row * i])
  }
}

///|
/// Tests the `Transpose::make`, `Transpose::map_col`, and `Transpose::map_row`
/// methods to verify they correctly construct transpose matrices and modify
/// columns and rows.
///
/// This test validates three key operations on transpose matrices:
///
/// 1. **Matrix Construction**: Creates a transpose matrix from a 2D array and
/// verifies the transposed structure
/// 2. **Transpose::make**: Tests the factory method that creates a transpose
/// matrix using a function to generate elements
/// 3. **Column Modification**: Tests `map_col` to apply a transformation
/// function to all elements in a specific column
/// 4. **Row Modification**: Tests `map_row` to apply a transformation function
/// to all elements in a specific row
///
/// The test demonstrates that:
///
/// * A 2×3 matrix `[[0, 1, 2], [3, 4, 5]]` becomes a 3×2 transpose matrix with
///   elements arranged as columns become rows
/// * `Transpose::make(3, 4, fn(i, j) { i + j })` creates a 3×4 matrix where
///   each element equals the sum of its column and row indices
/// * `map_col(0, fn(x) { x * 2 })` doubles all elements in the first column
///   (index 0)
/// * `map_row(0, fn(x) { x + 1 })` increments all elements in the first row
///   (index 0) by 1
///
/// The transformations are applied in sequence, showing how the transpose
/// matrix structure is preserved while individual elements are modified
/// according to the specified functions.
///
test "map" {
  let m = Matrix::from_2d_array([[0, 1, 2], [3, 4, 5]]).matrix_to_transpose()
  let m1 = Transpose::make(3, 4, fn(i, j) { i + j })
  inspect(
    m1,
    content=(
      #||0, 1, 2, 3|
      #||1, 2, 3, 4|
      #||2, 3, 4, 5|
    ),
  )
  m.map_col(0, fn(x) { x * 2 })
  inspect(
    m,
    content=(
      #||0, 3|
      #||2, 4|
      #||4, 5|
    ),
  )
  m.map_row(0, fn(x) { x + 1 })
  inspect(
    m,
    content=(
      #||1, 4|
      #||2, 4|
      #||4, 5|
    ),
  )
}

///|
/// Creates a deep copy of the transpose matrix.
///
/// Parameters:
///
/// * `self` : The transpose matrix to copy.
///
/// Returns a new transpose matrix with the same dimensions and a copy of all
/// elements from the original.
///
/// Example:
///
/// ```moonbit
/// let original = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let copied = original.copy()
/// // Modifying the copy doesn't affect the original
/// copied[0][0] = 999
/// inspect(original[0][0], content="1")
/// inspect(copied[0][0], content="999")
/// ```
///
pub fn[T] Transpose::copy(self : Transpose[T]) -> Transpose[T] {
  { row: self.row, col: self.col, data: self.data.copy() }
}

///|
/// Returns a lens object that provides access to a specific row of the
/// transpose matrix.
///
/// Parameters:
///
/// * `self` : The transpose matrix to access.
/// * `row` : The zero-based index of the row to access.
///
/// Returns a `LenTranspose[T]` object that allows getting and setting elements
/// in the specified row by column index.
///
/// Example:
///
/// ```moonbit
/// let m = @mutable.Matrix::from_2d_array([[1, 2, 3], [4, 5, 6]]).matrix_to_transpose()
/// let row_lens = m[0]  // Get access to the first row
/// inspect(row_lens[1], content="4")  // Access element at column 1
/// row_lens[1] = 10  // Set element at column 1 
/// inspect(row_lens[1], content="10")
/// ```
///
pub fn[T] Transpose::op_get(self : Transpose[T], row : Int) -> LenTranspose[T] {
  {
    set: (c, v) => self.data[row + self.row * c] = v,
    get: c => self.data[row + self.row * c],
  }
}

///|
/// Gets the element at the specified column index from the transpose row lens.
///
/// Parameters:
///
/// * `self` : The transpose row lens to access.
/// * `col` : The column index of the element to retrieve.
///
/// Returns the element at the specified column position.
///
pub fn[T] LenTranspose::op_get(self : LenTranspose[T], col : Int) -> T {
  (self.get)(col)
}

///|
/// Sets the element at the specified column position in the transpose lens.
///
/// Parameters:
///
/// * `self` : The `LenTranspose` object to modify.
/// * `col` : The column index where the element should be set.
/// * `elem` : The new element value to assign at the specified position.
///
pub fn[T] LenTranspose::op_set(
  self : LenTranspose[T],
  col : Int,
  elem : T,
) -> Unit {
  (self.set)(col, elem)
}

///|
/// Tests the indexing and assignment operations on a transposed matrix.
///
/// This test verifies that:
///
/// 1. Elements can be accessed using the `[row][col]` indexing syntax on a
/// transposed matrix
/// 2. Elements can be modified using the assignment operator `=` with the same
/// indexing syntax
/// 3. The changes are properly reflected when accessing the element again
///
/// The test creates a 2×3 matrix, converts it to its transpose (3×2), then
/// accesses and modifies an element at position \[0]\[1]. The original matrix
/// `[[2, 3, 4], [1, 2, 3]]` becomes `[[2, 1], [3, 2], [4, 3]]` when transposed,
/// so position \[0]\[1] corresponds to the value `1`, which is then changed to
/// `4`.
///
/// Example:
///
/// ```moonbit
/// test {
///   let m = Matrix::from_2d_array([[2, 3, 4], [1, 2, 3]]).matrix_to_transpose()
///   assert_eq(m[0][1], 1) // Access element
///   m[0][1] = 4                       // Modify element  
///   assert_eq(m[0][1], 4)  // Verify modification
/// }
/// ```
///
test "op_set" {
  let m = Matrix::from_2d_array([[2, 3, 4], [1, 2, 3]]).matrix_to_transpose()
  inspect(m[0][1], content="1")
  m[0][1] = 4
  inspect(m[0][1], content="4")
}

///|
/// Multiplies two transpose matrices using standard matrix multiplication.
///
/// Parameters:
///
/// * `self` : The left operand transpose matrix.
/// * `other` : The right operand transpose matrix.
///
/// Returns a new transpose matrix that is the product of `self` and `other`.
///
/// Panics if the number of columns in `self` does not equal the number of rows
/// in `other`.
///
/// Example:
///
/// ```moonbit
/// let m1 = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let m2 = Matrix::from_2d_array([[5, 6], [7, 8]]).matrix_to_transpose()
/// let result = m1 * m2
/// // Result will be equivalent to standard matrix multiplication
/// ```
///
pub impl[T : Mul + Add] Mul for Transpose[T] with op_mul(
  self : Transpose[T],
  other : Transpose[T],
) -> Transpose[T] {
  let row = self.row
  let col = other.col
  let inner = self.col
  guard inner == other.row
  let data = Array::makei(row * col, fn(i) {
    let r = i / row
    let c = i % row
    let mut sum = self.data[c] * other.data[other.row * r]
    for k in 1..<inner {
      sum += self.data[c + self.row * k] * other.data[k + other.row * r]
    }
    sum
  })
  { row, col, data }
}

///|
/// Performs element-wise addition of two transpose matrices.
///
/// Parameters:
///
/// * `self` : The first transpose matrix.
/// * `other` : The second transpose matrix to add.
///
/// Returns a new transpose matrix containing the element-wise sum of the two
/// input matrices.
///
/// Panics if the dimensions of the two matrices do not match (different number
/// of rows or columns).
///
/// Example:
///
/// ```moonbit
/// let m1 = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let m2 = Matrix::from_2d_array([[5, 6], [7, 8]]).matrix_to_transpose()
/// let result = m1 + m2
/// // result represents the transpose of [[6, 8], [10, 12]]
/// ```
///
pub impl[T : Add] Add for Transpose[T] with op_add(
  self : Transpose[T],
  other : Transpose[T],
) -> Transpose[T] {
  guard self.col == other.col
  guard self.row == other.row
  {
    data: array_zip_with(self.data, other.data, T::op_add),
    row: self.row,
    col: self.col,
  }
}

///|
/// Computes the negation of a transpose matrix.
///
/// Parameters:
///
/// * `self` : The transpose matrix to negate.
///
/// Returns a new transpose matrix where each element is the negation of the
/// corresponding element in the input matrix.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([[1, -2], [3, -4]]).matrix_to_transpose()
/// let negated = -m
/// inspect(negated, content="|-1, -3|\n|2, 4|")
/// ```
///
pub impl[T : Neg] Neg for Transpose[T] with op_neg(self : Transpose[T]) -> Transpose[
  T,
] {
  self.map(T::op_neg)
}

///|
/// Subtracts one transpose matrix from another.
///
/// Parameters:
///
/// * `self` : The minuend transpose matrix.
/// * `other` : The subtrahend transpose matrix to subtract from `self`.
///
/// Returns a new transpose matrix that is the difference between `self` and
/// `other`.
///
/// Panics if the dimensions of `self` and `other` do not match.
///
/// Example:
///
/// ```moonbit
/// let m1 = Matrix::from_2d_array([[5, 8], [3, 6]]).matrix_to_transpose()
/// let m2 = Matrix::from_2d_array([[2, 3], [1, 2]]).matrix_to_transpose()
/// let result = m1 - m2
/// inspect(result, content="|3, 2|\n|5, 4|")
/// ```
///
pub impl[T : Add + Neg] Sub for Transpose[T] with op_sub(
  self : Transpose[T],
  other : Transpose[T],
) -> Transpose[T] {
  self + -other
}

///|
/// Scales all elements of the transpose matrix by a constant factor.
///
/// Parameters:
///
/// * `self` : The transpose matrix to be scaled.
/// * `cst` : The constant factor to multiply each element by.
///
/// Returns a new transpose matrix with all elements multiplied by the constant
/// factor.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let scaled = m.scale(2)
/// inspect(scaled, content="|2, 6|\n|4, 8|")
/// ```
///
pub fn[T : Mul] Transpose::scale(self : Transpose[T], cst : T) -> Transpose[T] {
  self.map(fn(x) { x * cst })
}

///|
/// Adds a constant to each element of the transpose matrix.
///
/// Parameters:
///
/// * `self` : The transpose matrix to add the constant to.
/// * `cst` : The constant value to add to each element.
///
/// Returns a new transpose matrix with the constant added to each element.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let result = m.add_constant(5)
/// // result will be a transpose matrix equivalent to [[6, 8], [7, 9]]
/// ```
///
pub fn[T : Add] Transpose::add_constant(
  self : Transpose[T],
  cst : T,
) -> Transpose[T] {
  self.map(fn(x) { x + cst })
}

///|
/// Checks if the transpose matrix is a null (zero) matrix.
///
/// Parameters:
///
/// * `self` : The transpose matrix to check.
///
/// Returns `true` if all elements in the matrix are zero, `false` otherwise.
///
/// Example:
///
/// ```moonbit
/// let zero_matrix = Matrix::new(2, 3, 0).matrix_to_transpose()
/// let non_zero_matrix = Matrix::from_2d_array([[1, 0], [0, 0]]).matrix_to_transpose()
/// inspect(zero_matrix.null(), content="true")
/// inspect(non_zero_matrix.null(), content="false")
/// ```
///
pub fn[T : Compare + Zero] Transpose::null(self : Transpose[T]) -> Bool {
  not(self.data.iter().any(fn(x) { x != T::zero() }))
}

///|
/// Computes the adjoint (conjugate transpose) of a transpose matrix by applying
/// the conjugate operation to each element.
///
/// Parameters:
///
/// * `self` : The transpose matrix to compute the adjoint of.
///
/// Returns a new transpose matrix where each element is the conjugate of the
/// corresponding element in the input matrix.
pub fn[T : Conjugate] Transpose::adjoint(self : Transpose[T]) -> Transpose[T] {
  self.map(T::conjugate)
}

///|
/// Swaps two columns in the transposed matrix.
///
/// Parameters:
///
/// * `self` : The transposed matrix to modify.
/// * `c1` : The index of the first column to swap.
/// * `c2` : The index of the second column to swap.
///
/// Panics if either `c1` or `c2` is negative or greater than or equal to the
/// number of columns in the matrix.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([[1, 2, 3], [4, 5, 6]]).matrix_to_transpose()
/// m.swap_cols(0, 1)
/// // The matrix now has columns 0 and 1 swapped
/// ```
///
pub fn[T] Transpose::swap_cols(self : Transpose[T], c1 : Int, c2 : Int) -> Unit {
  let r = self.row
  let c = self.col
  guard c1 < c && c2 < c && c1 >= 0 && c2 >= 0
  if c1 == c2 {
    return
  }
  let temp = Array::makei(r, fn(i) { self.data[i + r * c1] })
  for i in 0..<r {
    self.data[i + r * c1] = self.data[i + r * c2]
  }
  for i in 0..<r {
    self.data[i + r * c2] = temp[i]
  }
}

///|
/// Swaps two rows in the transpose matrix in-place.
///
/// Parameters:
///
/// * `self` : The transpose matrix to modify.
/// * `r1` : The index of the first row to swap.
/// * `r2` : The index of the second row to swap.
///
/// Panics if either `r1` or `r2` is negative or greater than or equal to the
/// number of rows in the matrix.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// m.swap_rows(0, 1)
/// // The matrix is now: |2, 4| \n |1, 3|
/// ```
///
pub fn[T] Transpose::swap_rows(self : Transpose[T], r1 : Int, r2 : Int) -> Unit {
  let r = self.row
  let c = self.col
  guard r1 < r && r2 < r && r1 >= 0 && r2 >= 0
  if r1 == r2 {
    return
  }
  let temp = Array::makei(c, fn(i) { self.data[r1 + r * i] })
  for i in 0..<c {
    self.data[r1 + r * i] = self.data[r2 + r * i]
  }
  for i in 0..<c {
    self.data[r2 + r * i] = temp[i]
  }
}

///|
/// Computes the matrix power by raising the transpose matrix to the given
/// integer exponent.
///
/// Parameters:
///
/// * `self` : The transpose matrix to be raised to a power.
/// * `power` : The non-negative integer exponent.
///
/// Returns the transpose matrix raised to the specified power.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([[1, 2], [0, 1]]).matrix_to_transpose()
/// let m_squared = m.pow(2)
/// inspect(m_squared, content="|1, 0|\n|4, 1|")
/// ```
///
pub fn[T : Semiring] Transpose::pow(
  self : Transpose[T],
  power : Int,
) -> Transpose[T] {
  loop (identity(self.col).matrix_to_transpose(), power, self) {
    (s, 0, _) => s
    (s, 1, m) => s * m
    (s, p, m) => continue (if (p & 1) == 1 { s * m } else { s }, p >> 1, m * m)
  }
}

///|
/// Performs Gaussian elimination with partial pivoting to transform the
/// transpose matrix into its reduced row echelon form.
///
/// Parameters:
///
/// * `self` : The transpose matrix to be reduced using row elimination
///   operations.
///
/// Returns a new `Transpose[T]` matrix in reduced row echelon form.
///
/// Panics if the matrix contains elements that cannot be inverted when a pivot
/// element is encountered.
///
/// Example:
///
/// ```moonbit
/// let m = Matrix::from_2d_array([
///   [1.0, 2.0, 3.0],
///   [4.0, 5.0, 6.0],
///   [7.0, 8.0, 9.0]
/// ]).matrix_to_transpose()
///
/// let reduced = m.reduce_row_elimination()
/// // The resulting matrix will be in reduced row echelon form
/// ```
///
pub fn[T : Compare + Num + Sub + Inverse] Transpose::reduce_row_elimination(
  self : Transpose[T],
) -> Transpose[T] {
  let r = self.row
  let c = self.col
  let mut col = 0
  for i in 0..<r {
    if col >= c {
      break
    }
    let mut max_row = i
    for j in (i + 1)..<r {
      if self.data[j + r * col].abs() > self.data[max_row + r * col].abs() {
        max_row = j
      }
    }
    ignore(self.swap_rows(i, max_row))
    if self.data[i + r * col] == T::zero() {
      col = col + 1
      continue
    }
    let val = self.data[i + r * col]
    ignore(self.map_row(i, fn(x) { x * val.inv() }))
    for j in 0..<r {
      if j == i {
        continue
      }
      let factor = self.data[j + r * col]
      for k in 0..<c {
        self.data[j + r * k] = self.data[j + r * k] -
          self.data[i + r * k] * factor
      }
    }
    col = col + 1
  }
  self
}

///|
/// Combines two transpose matrices horizontally by placing them side by side.
///
/// Parameters:
///
/// * `self` : The left transpose matrix to combine.
/// * `other` : The right transpose matrix to combine.
///
/// Returns a new transpose matrix with `self` on the left and `other` on the
/// right.
///
/// Panics if `self` and `other` have different numbers of rows.
///
/// Example:
///
/// ```moonbit
/// let m1 = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let m2 = Matrix::from_2d_array([[5, 6], [7, 8]]).matrix_to_transpose()
/// let combined = m1.horizontal_combine(m2)
/// // combined represents: |1, 3, 5, 7|
/// //                     |2, 4, 6, 8|
/// ```
///
pub fn[T] Transpose::horizontal_combine(
  self : Transpose[T],
  other : Transpose[T],
) -> Transpose[T] {
  guard self.row == other.row
  Transpose::make(self.row, self.col + other.col, fn(i, j) {
    if i < self.col {
      self.data[j + self.row * i]
    } else {
      other.data[j + self.row * (i - self.col)]
    }
  })
}

///|
/// Vertically combines two transpose matrices by stacking the second matrix
/// below the first matrix.
///
/// Parameters:
///
/// * `self` : The first transpose matrix to be placed on top.
/// * `other` : The second transpose matrix to be placed below the first matrix.
///
/// Returns a new transpose matrix with `self.row + other.row` rows and the same
/// number of columns as both input matrices.
///
/// Panics if the two matrices do not have the same number of columns.
///
/// Example:
///
/// ```moonbit
/// let m1 = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// let m2 = Matrix::from_2d_array([[5, 6], [7, 8]]).matrix_to_transpose()
/// let combined = m1.vertical_combine(m2)
/// // Result will be a 4×2 transpose matrix containing:
/// // |1, 3|
/// // |2, 4|  
/// // |5, 7|
/// // |6, 8|
/// ```
///
pub fn[T] Transpose::vertical_combine(
  self : Transpose[T],
  other : Transpose[T],
) -> Transpose[T] {
  guard self.col == other.col
  Transpose::make(self.row + other.row, self.col, fn(i, j) {
    if j < self.row {
      self.data[j + self.row * i]
    } else {
      other.data[j - self.row + self.row * i]
    }
  })
}

///|
/// Converts a transpose matrix back to a regular matrix.
///
/// Parameters:
///
/// * `self` : The transpose matrix to convert.
///
/// Returns a `Matrix[T]` with the same logical structure as the original
/// transpose matrix, where rows and columns are swapped back to their standard
/// representation.
///
/// Example:
///
/// ```moonbit
/// let transpose_matrix = Matrix::from_2d_array([[1, 2, 3], [4, 5, 6]]).matrix_to_transpose()
/// inspect(transpose_matrix, content="|1, 4|\n|2, 5|\n|3, 6|")
/// ```
///
pub fn[T] Transpose::transpose_to_matrix(self : Transpose[T]) -> Matrix[T] {
  let data = Array::makei(self.col * self.row, fn(i) {
    let row = i / self.col
    let col = i % self.col
    self.data[row + self.row * col]
  })
  { row: self.col, col: self.row, data }
}

///|
/// Tests the addition operation for transposed matrices and verifies the
/// conversion back to regular matrix format.
///
/// This test creates two column vectors as transposed matrices, performs
/// element-wise addition, and validates both the transposed result and its
/// conversion back to a regular matrix. It ensures that the `Add` trait
/// implementation for `Transpose[T]` works correctly and maintains proper data
/// integrity during matrix format conversions.
///
/// Example:
///
/// ```moonbit
/// test "add" {
///   let m1 = Matrix::from_2d_array([[1], [1], [1]]).matrix_to_transpose()
///   let m2 = Matrix::from_2d_array([[2], [3], [4]]).matrix_to_transpose()
///   let m3 = (m1 + m2).transpose_to_matrix()
///   inspect(m1 + m2, content="|3, 4, 5|")
///   inspect(
///     m3,
///     content=(
///       #||3|
///       #||4|
///       #||5|
///     ),
///   )
/// }
/// ```
///
test "add" {
  let m1 = Matrix::from_2d_array([[1], [1], [1]]).matrix_to_transpose()
  let m2 = Matrix::from_2d_array([[2], [3], [4]]).matrix_to_transpose()
  let m3 = (m1 + m2).transpose_to_matrix()
  inspect(m1 + m2, content="|3, 4, 5|")
  inspect(
    m3,
    content=(
      #||3|
      #||4|
      #||5|
    ),
  )
}

///|
/// Tests the row and column swapping operations for transpose matrices.
///
/// This test verifies that the `swap_rows` and `swap_cols` methods work
/// correctly on transpose matrices by:
///
/// 1. Creating a transpose matrix from a 2x3 matrix `[[1, 2, 3], [4, 5, 6]]`
/// 2. Testing row swapping by swapping rows 0 and 1
/// 3. Testing column swapping by swapping columns 0 and 1
/// 4. Verifying the results match expected transpose matrix layouts
///
/// The test demonstrates that:
///
/// * The original matrix `[[1, 2, 3], [4, 5, 6]]` becomes transpose matrix with
///   layout `|1, 4|, |2, 5|, |3, 6|`
/// * After swapping rows 0 and 1, the result is `|2, 5|, |1, 4|, |3, 6|`
/// * After swapping columns 0 and 1, the result is `|4, 1|, |5, 2|, |6, 3|`
///
/// Note that in transpose matrix representation, the internal storage and
/// indexing differs from regular matrices, so row and column operations produce
/// results that may appear counterintuitive compared to standard matrix
/// operations.
///
test "swap" {
  let m = Matrix::from_2d_array([[1, 2, 3], [4, 5, 6]]).matrix_to_transpose()
  let m1 = {
    let m_ = m.copy()
    m_.swap_rows(0, 1)
    m_
  }
  let m2 = {
    let m_ = m.copy()
    m_.swap_cols(0, 1)
    m_
  }
  inspect(
    m,
    content=(
      #||1, 4|
      #||2, 5|
      #||3, 6|
    ),
  )
  inspect(
    m1,
    content=(
      #||2, 5|
      #||1, 4|
      #||3, 6|
    ),
  )
  inspect(
    m2,
    content=(
      #||4, 1|
      #||5, 2|
      #||6, 3|
    ),
  )
}

///|
/// Tests the horizontal and vertical combination operations for transpose
/// matrices.
///
/// This test verifies that:
///
/// 1. `Transpose::horizontal_combine` correctly concatenates two transpose
/// matrices side by side
/// 2. `Transpose::vertical_combine` correctly stacks two transpose matrices
/// vertically
///
/// The test creates two 2x2 transpose matrices:
///
/// * `m1`: A transpose matrix containing `[[1, 2], [3, 4]]` (displayed as
///   transpose form)
/// * `m2`: A transpose matrix containing the identity matrix `[[1, 0], [0, 1]]`
///   (displayed as transpose form)
///
/// For horizontal combination, the matrices are combined side by side,
/// resulting in a 2x4 transpose matrix.
/// For vertical combination, the matrices are stacked vertically, resulting in
/// a 4x2 transpose matrix.
///
/// The test validates the correctness of both operations by inspecting the
/// expected output formats of the combined matrices.
///
test "matrix_combine" {
  let m1 = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
  let m2 = Matrix::from_2d_array([[1, 0], [0, 1]]).matrix_to_transpose()
  let m3 = Transpose::horizontal_combine(m1, m2)
  let m4 = Transpose::vertical_combine(m1, m2)
  inspect(
    m3,
    content=(
      #||1, 3, 1, 0|
      #||2, 4, 0, 1|
    ),
  )
  inspect(
    m4,
    content=(
      #||1, 3|
      #||2, 4|
      #||1, 0|
      #||0, 1|
    ),
  )
}

///|
/// Tests the conversion of a matrix to its transpose representation.
///
/// This test verifies that `Matrix::matrix_to_transpose()` correctly converts a
/// regular matrix into a `Transpose[T]` data structure, where elements are
/// stored in column-major order instead of row-major order.
///
/// Example:
///
/// ```moonbit
/// let m1 = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
/// inspect(
///   m1,
///   content=(
///     #||1, 3|
///     #||2, 4|
///   ),
/// )
/// ```
test "to transpose" {
  let m1 = Matrix::from_2d_array([[1, 2], [3, 4]]).matrix_to_transpose()
  inspect(
    m1,
    content=(
      #||1, 3|
      #||2, 4|
    ),
  )
}

///|
/// Tests the row elimination (Gaussian elimination) operation on a transpose
/// matrix to produce reduced row echelon form.
///
/// This test verifies that the `reduce_row_elimination` method correctly
/// transforms a 5×4 transpose matrix into its reduced row echelon form. The
/// test uses a matrix with floating-point elements and checks that the
/// resulting matrix has the expected pivot positions (leading 1s) and zero
/// entries in appropriate positions.
///
/// The input matrix represents a system of linear equations in transpose form:
///
/// * Original matrix: 5 rows × 4 columns
/// * After row elimination: Identity-like structure with a solution column
///
/// The expected output shows:
///
/// * Row 1: \[1, 0, 0, 0, 0.48461538461538456] - first pivot in column 1
/// * Row 2: \[0, 1, 0, 0, -0.9615384615384615] - second pivot in column 2
/// * Row 3: \[0, 0, 1, 0, -0.6769230769230766] - third pivot in column 3
/// * Row 4: \[0, 0, 0, 1, 1.9230769230769227] - fourth pivot in column 4
///
/// This demonstrates that the algorithm correctly identifies pivot columns,
/// performs row swapping for numerical stability, and reduces the matrix to its
/// canonical form.
///
test "reduce_row_elimination" {
  let m = Matrix::from_2d_array([
    [1.0, 2.0, 3.0, 7.0],
    [1.0, 1.0, 1.0, 2.0],
    [2.0, 3.0, 3.0, 5.0],
    [2.2, 2.3, 2.1, 2.4],
    [2.4, 2.4, 2.5, 2.7],
  ]).matrix_to_transpose()
  inspect(
    m.reduce_row_elimination(),
    content=(
      #||1, 0, 0, 0, 0.48461538461538456|
      #||0, 1, 0, 0, -0.9615384615384615|
      #||0, 0, 1, 0, -0.6769230769230766|
      #||0, 0, 0, 1, 1.9230769230769227|
    ),
  )
}
